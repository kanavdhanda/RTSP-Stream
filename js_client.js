/**
 * JavaScript/WebSocket client for the RTSP Stream Server
 * This client can be used in your Wails React frontend
 */

class RTSPStreamClient {
    constructor(serverUrl = 'ws://localhost:8091', streamId = 'camera1') {
        this.serverUrl = serverUrl.replace(/^http/, 'ws');
        this.httpServerUrl = serverUrl.replace(/^ws/, 'http');
        this.streamId = streamId;
        this.ws = null;
        this.canvas = null;
        this.ctx = null;
        this.width = 640;
        this.height = 480;
        this.isConnected = false;
        this.frameCallback = null;
        this.errorCallback = null;
        this.connectCallback = null;
        this.disconnectCallback = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000; // Start with 1 second
        this.stats = {
            framesReceived: 0,
            bytesReceived: 0,
            lastFrameTime: null,
            averageFps: 0,
            startTime: Date.now()
        };
    }

    /**
     * Set up canvas for rendering frames
     */
    setupCanvas(canvasElement) {
        this.canvas = canvasElement;
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    }

    /**
     * Start a stream on the server with just URL (server will generate stream ID)
     */
    async startStreamWithURL(rtspUrl, width = 640, height = 480) {
        this.width = width;
        this.height = height;
        
        if (this.canvas) {
            this.canvas.width = width;
            this.canvas.height = height;
        }

        const payload = {
            rtsp_url: rtspUrl,
            width: width,
            height: height
        };

        try {
            const response = await fetch(`${this.httpServerUrl}/api/streams/start-with-url`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
            }

            const result = await response.json();
            console.log('Stream started:', result);
            
            // Update stream ID with the one generated by server
            this.streamId = result.stream_id;
            
            return {
                success: true,
                streamId: result.stream_id,
                ...result
            };
        } catch (error) {
            console.error('Failed to start stream:', error);
            if (this.errorCallback) {
                this.errorCallback(`Failed to start stream: ${error.message}`);
            }
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Start a stream on the server
     */
    async startStream(rtspUrl, width = 640, height = 480) {
        this.width = width;
        this.height = height;
        
        if (this.canvas) {
            this.canvas.width = width;
            this.canvas.height = height;
        }

        const payload = {
            stream_id: this.streamId,
            rtsp_url: rtspUrl,
            width: width,
            height: height
        };

        try {
            const response = await fetch(`${this.httpServerUrl}/api/streams`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
            }

            const result = await response.json();
            console.log('Stream started:', result);
            return true;
        } catch (error) {
            console.error('Failed to start stream:', error);
            if (this.errorCallback) {
                this.errorCallback(`Failed to start stream: ${error.message}`);
            }
            return false;
        }
    }

    /**
     * Stop the stream on the server
     */
    async stopStream() {
        try {
            const response = await fetch(`${this.httpServerUrl}/api/streams/${this.streamId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                const result = await response.json();
                console.log('Stream stopped:', result);
                return true;
            } else {
                console.warn('Stream may not exist on server');
                return true; // Consider it successful if stream doesn't exist
            }
        } catch (error) {
            console.error('Failed to stop stream:', error);
            return false;
        }
    }

    /**
     * Get stream statistics from server
     */
    async getStreamStats() {
        try {
            const response = await fetch(`${this.httpServerUrl}/api/streams/${this.streamId}/stats`);
            if (response.ok) {
                return await response.json();
            }
            return null;
        } catch (error) {
            console.error('Failed to get stream stats:', error);
            return null;
        }
    }

    /**
     * Connect to WebSocket stream
     */
    connect() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            return;
        }

        const wsUrl = `${this.serverUrl}/ws/${this.streamId}`;
        console.log('Connecting to WebSocket:', wsUrl);

        this.ws = new WebSocket(wsUrl);
        this.ws.binaryType = 'arraybuffer';

        this.ws.onopen = (event) => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 1000;
            
            if (this.connectCallback) {
                this.connectCallback(event);
            }
        };

        this.ws.onmessage = (event) => {
            this.handleFrame(event.data);
        };

        this.ws.onclose = (event) => {
            console.log('WebSocket disconnected:', event.code, event.reason);
            this.isConnected = false;
            
            if (this.disconnectCallback) {
                this.disconnectCallback(event);
            }

            // Attempt reconnection if it wasn't a clean close
            if (!event.wasClean && this.reconnectAttempts < this.maxReconnectAttempts) {
                this.scheduleReconnect();
            }
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            if (this.errorCallback) {
                this.errorCallback(`WebSocket error: ${error.message || 'Connection failed'}`);
            }
        };
    }

    /**
     * Schedule a reconnection attempt
     */
    scheduleReconnect() {
        this.reconnectAttempts++;
        console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${this.reconnectDelay}ms`);
        
        setTimeout(() => {
            this.connect();
            this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000); // Cap at 30 seconds
        }, this.reconnectDelay);
    }

    /**
     * Handle incoming frame data
     */
    handleFrame(arrayBuffer) {
        const frameData = new Uint8Array(arrayBuffer);
        const expectedSize = this.width * this.height * 3; // BGR24

        if (frameData.length !== expectedSize) {
            console.warn(`Received frame with unexpected size: ${frameData.length} (expected ${expectedSize})`);
            return;
        }

        // Update statistics
        this.stats.framesReceived++;
        this.stats.bytesReceived += frameData.length;
        this.stats.lastFrameTime = Date.now();
        
        // Calculate average FPS
        const elapsed = (Date.now() - this.stats.startTime) / 1000;
        this.stats.averageFps = this.stats.framesReceived / elapsed;

        // Convert BGR24 to ImageData for canvas
        if (this.canvas && this.ctx) {
            this.renderToCanvas(frameData);
        }

        // Call user-defined frame callback
        if (this.frameCallback) {
            this.frameCallback(frameData, this.width, this.height);
        }
    }

    /**
     * Render frame to canvas
     */
    renderToCanvas(bgrData) {
        const imageData = this.ctx.createImageData(this.width, this.height);
        const data = imageData.data;

        // Convert BGR24 to RGBA
        for (let i = 0; i < bgrData.length; i += 3) {
            const pixelIndex = (i / 3) * 4;
            data[pixelIndex] = bgrData[i + 2];     // R (from B)
            data[pixelIndex + 1] = bgrData[i + 1]; // G
            data[pixelIndex + 2] = bgrData[i];     // B (from R)
            data[pixelIndex + 3] = 255;            // A
        }

        this.ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Disconnect from WebSocket
     */
    disconnect() {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
        this.isConnected = false;
    }

    /**
     * Set callback for frame reception
     */
    onFrame(callback) {
        this.frameCallback = callback;
    }

    /**
     * Set callback for errors
     */
    onError(callback) {
        this.errorCallback = callback;
    }

    /**
     * Set callback for connection events
     */
    onConnect(callback) {
        this.connectCallback = callback;
    }

    /**
     * Set callback for disconnection events
     */
    onDisconnect(callback) {
        this.disconnectCallback = callback;
    }

    /**
     * Get client statistics
     */
    getStats() {
        return { ...this.stats };
    }

    /**
     * Reset statistics
     */
    resetStats() {
        this.stats = {
            framesReceived: 0,
            bytesReceived: 0,
            lastFrameTime: null,
            averageFps: 0,
            startTime: Date.now()
        };
    }
}

// React Hook for easier integration
if (typeof React !== 'undefined') {
    const { useState, useEffect, useRef, useCallback } = React;

    function useRTSPStream(serverUrl, streamId) {
        const [client] = useState(() => new RTSPStreamClient(serverUrl, streamId));
        const [isConnected, setIsConnected] = useState(false);
        const [error, setError] = useState(null);
        const [stats, setStats] = useState(null);
        const canvasRef = useRef(null);

        useEffect(() => {
            if (canvasRef.current) {
                client.setupCanvas(canvasRef.current);
            }

            client.onConnect(() => {
                setIsConnected(true);
                setError(null);
            });

            client.onDisconnect(() => {
                setIsConnected(false);
            });

            client.onError((error) => {
                setError(error);
            });

            client.onFrame(() => {
                setStats(client.getStats());
            });

            return () => {
                client.disconnect();
            };
        }, [client]);

        const startStream = useCallback(async (rtspUrl, width, height) => {
            const success = await client.startStream(rtspUrl, width, height);
            if (success) {
                // Wait a moment for stream to initialize
                setTimeout(() => {
                    client.connect();
                }, 1000);
            }
            return success;
        }, [client]);

        const stopStream = useCallback(async () => {
            client.disconnect();
            return await client.stopStream();
        }, [client]);

        return {
            canvasRef,
            isConnected,
            error,
            stats,
            startStream,
            stopStream,
            client
        };
    }

    // Make the hook available globally
    if (typeof window !== 'undefined') {
        window.useRTSPStream = useRTSPStream;
    }
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = RTSPStreamClient;
}

// Make available globally
if (typeof window !== 'undefined') {
    window.RTSPStreamClient = RTSPStreamClient;
}
