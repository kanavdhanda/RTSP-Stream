/**
 * JavaScript/WebSocket client for the RTSP Stream Server
 * This client is compatible with the updated server that prevents channel close panics
 * and includes proper client management.
 */

class RTSPStreamClient {
    constructor(serverUrl = 'ws://localhost:8091', streamId = 'camera1') {
        this.serverUrl = serverUrl.replace(/^http/, 'ws');
        this.httpServerUrl = serverUrl.replace(/^ws/, 'http');
        this.streamId = streamId;
        this.ws = null;
        this.canvas = null;
        this.ctx = null;
        this.width = 640;
        this.height = 480;
        this.isConnected = false;
        this.isReconnecting = false;
        this.frameCallback = null;
        this.errorCallback = null;
        this.connectCallback = null;
        this.disconnectCallback = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000; // Start with 1 second
        this.heartbeatInterval = null;
        this.stats = {
            framesReceived: 0,
            bytesReceived: 0,
            lastFrameTime: null,
            averageFps: 0,
            startTime: Date.now(),
            reconnectCount: 0
        };
    }

    /**
     * Set up canvas for rendering frames
     */
    setupCanvas(canvasElement) {
        this.canvas = canvasElement;
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        // Add error handling for canvas
        try {
            // Test if canvas context is working
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(0, 0, 1, 1);
        } catch (error) {
            console.error('Canvas setup failed:', error);
            if (this.errorCallback) {
                this.errorCallback(`Canvas setup failed: ${error.message}`);
            }
        }
    }

    /**
     * Start a stream on the server with just URL (server will generate stream ID)
     * This is the recommended method as it handles stream ID generation automatically
     */
    async startStreamWithURL(rtspUrl, width = 640, height = 480) {
        this.width = width;
        this.height = height;
        
        if (this.canvas) {
            this.canvas.width = width;
            this.canvas.height = height;
        }

        const payload = {
            rtsp_url: rtspUrl,
            width: width,
            height: height
        };

        try {
            console.log('Starting stream with URL:', rtspUrl);
            const response = await fetch(`${this.httpServerUrl}/api/streams/start-with-url`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
                signal: AbortSignal.timeout(10000) // 10 second timeout
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const result = await response.json();
            console.log('Stream started successfully:', result);
            
            // Update stream ID with the one generated by server
            this.streamId = result.stream_id;
            
            return {
                success: true,
                streamId: result.stream_id,
                message: result.message,
                rtspUrl: result.rtsp_url,
                width: result.width,
                height: result.height
            };
        } catch (error) {
            console.error('Failed to start stream:', error);
            if (this.errorCallback) {
                this.errorCallback(`Failed to start stream: ${error.message}`);
            }
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Start a stream on the server with explicit stream ID
     */
    async startStream(rtspUrl, width = 640, height = 480) {
        this.width = width;
        this.height = height;
        
        if (this.canvas) {
            this.canvas.width = width;
            this.canvas.height = height;
        }

        const payload = {
            stream_id: this.streamId,
            rtsp_url: rtspUrl,
            width: width,
            height: height
        };

        try {
            console.log('Starting stream with ID:', this.streamId);
            const response = await fetch(`${this.httpServerUrl}/api/streams`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
                signal: AbortSignal.timeout(10000) // 10 second timeout
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const result = await response.json();
            console.log('Stream started successfully:', result);
            
            return {
                success: true,
                message: result.message,
                streamId: result.stream_id
            };
        } catch (error) {
            console.error('Failed to start stream:', error);
            if (this.errorCallback) {
                this.errorCallback(`Failed to start stream: ${error.message}`);
            }
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Stop the stream on the server (only if no other clients are connected)
     */
    async stopStream() {
        try {
            console.log('Attempting to stop stream:', this.streamId);
            const response = await fetch(`${this.httpServerUrl}/api/streams/${this.streamId}`, {
                method: 'DELETE',
                signal: AbortSignal.timeout(5000) // 5 second timeout
            });

            if (response.ok) {
                const result = await response.json();
                console.log('Stream stopped successfully:', result);
                return {
                    success: true,
                    message: result.message
                };
            } else if (response.status === 409) {
                // Conflict - other clients still connected
                const result = await response.json();
                console.warn('Cannot stop stream - other clients connected:', result);
                return {
                    success: false,
                    error: result.error,
                    clientCount: result.client_count,
                    conflict: true
                };
            } else if (response.status === 404) {
                // Stream not found - consider it successful
                console.warn('Stream not found on server (may have been stopped already)');
                return {
                    success: true,
                    message: 'Stream not found (may have been stopped already)'
                };
            } else {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
        } catch (error) {
            console.error('Failed to stop stream:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Force stop the stream on the server (disconnects all clients)
     */
    async forceStopStream() {
        try {
            console.log('Force stopping stream:', this.streamId);
            const response = await fetch(`${this.httpServerUrl}/api/streams/${this.streamId}/force`, {
                method: 'DELETE',
                signal: AbortSignal.timeout(5000) // 5 second timeout
            });

            if (response.ok) {
                const result = await response.json();
                console.log('Stream force-stopped successfully:', result);
                return {
                    success: true,
                    message: result.message
                };
            } else if (response.status === 404) {
                console.warn('Stream not found on server');
                return {
                    success: true,
                    message: 'Stream not found'
                };
            } else {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
        } catch (error) {
            console.error('Failed to force stop stream:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Get stream statistics from server
     */
    async getStreamStats() {
        try {
            const response = await fetch(`${this.httpServerUrl}/api/streams/${this.streamId}/stats`, {
                signal: AbortSignal.timeout(5000) // 5 second timeout
            });
            
            if (response.ok) {
                const stats = await response.json();
                console.log('Server stats:', stats);
                return stats;
            } else if (response.status === 404) {
                console.warn('Stream not found for stats');
                return null;
            } else {
                console.error('Failed to get stream stats:', response.status);
                return null;
            }
        } catch (error) {
            console.error('Failed to get stream stats:', error);
            return null;
        }
    }

    /**
     * List all streams on the server
     */
    async listStreams() {
        try {
            const response = await fetch(`${this.httpServerUrl}/api/streams`, {
                signal: AbortSignal.timeout(5000)
            });
            
            if (response.ok) {
                const result = await response.json();
                return result.streams || [];
            } else {
                console.error('Failed to list streams:', response.status);
                return [];
            }
        } catch (error) {
            console.error('Failed to list streams:', error);
            return [];
        }
    }

    /**
     * Connect to WebSocket stream with improved error handling
     */
    connect() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            console.log('WebSocket already connected');
            return;
        }

        if (this.isReconnecting) {
            console.log('Reconnection already in progress');
            return;
        }

        const wsUrl = `${this.serverUrl}/ws/${this.streamId}`;
        console.log('Connecting to WebSocket:', wsUrl);

        // Clean up existing connection
        this.disconnect();

        this.ws = new WebSocket(wsUrl);
        this.ws.binaryType = 'arraybuffer';

        this.ws.onopen = (event) => {
            console.log('WebSocket connected successfully');
            this.isConnected = true;
            this.isReconnecting = false;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 1000; // Reset delay
            
            // Start heartbeat to keep connection alive
            this.startHeartbeat();
            
            if (this.connectCallback) {
                this.connectCallback(event);
            }
        };

        this.ws.onmessage = (event) => {
            this.handleFrame(event.data);
        };

        this.ws.onclose = (event) => {
            console.log('WebSocket disconnected:', event.code, event.reason);
            this.isConnected = false;
            this.stopHeartbeat();
            
            if (this.disconnectCallback) {
                this.disconnectCallback(event);
            }

            // Only attempt reconnection for unexpected closes
            if (!event.wasClean && 
                event.code !== 1000 && // Normal closure
                event.code !== 1001 && // Going away
                this.reconnectAttempts < this.maxReconnectAttempts) {
                this.scheduleReconnect();
            } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                console.error('Max reconnection attempts reached');
                if (this.errorCallback) {
                    this.errorCallback('Max reconnection attempts reached');
                }
            }
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.isConnected = false;
            this.stopHeartbeat();
            
            if (this.errorCallback) {
                this.errorCallback(`WebSocket error: ${error.message || 'Connection failed'}`);
            }
        };
    }

    /**
     * Start heartbeat to keep connection alive
     */
    startHeartbeat() {
        this.stopHeartbeat(); // Clear any existing heartbeat
        
        this.heartbeatInterval = setInterval(() => {
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                try {
                    // Send ping frame (this is handled by the browser/server automatically)
                    this.ws.send(new ArrayBuffer(0));
                } catch (error) {
                    console.error('Heartbeat failed:', error);
                    this.disconnect();
                }
            }
        }, 30000); // Send heartbeat every 30 seconds
    }

    /**
     * Stop heartbeat
     */
    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }

    /**
     * Schedule a reconnection attempt with exponential backoff
     */
    scheduleReconnect() {
        if (this.isReconnecting) {
            return;
        }

        this.isReconnecting = true;
        this.reconnectAttempts++;
        this.stats.reconnectCount++;
        
        console.log(`Scheduling reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${this.reconnectDelay}ms`);
        
        setTimeout(() => {
            if (this.isReconnecting) { // Check if we still want to reconnect
                this.connect();
                this.reconnectDelay = Math.min(this.reconnectDelay * 1.5, 30000); // Cap at 30 seconds
            }
        }, this.reconnectDelay);
    }

    /**
     * Handle incoming frame data with improved error checking
     */
    handleFrame(arrayBuffer) {
        if (!arrayBuffer || arrayBuffer.byteLength === 0) {
            console.warn('Received empty frame data');
            return;
        }

        const frameData = new Uint8Array(arrayBuffer);
        const expectedSize = this.width * this.height * 3; // BGR24

        if (frameData.length !== expectedSize) {
            console.warn(`Received frame with unexpected size: ${frameData.length} (expected ${expectedSize})`);
            return;
        }

        // Update statistics
        this.stats.framesReceived++;
        this.stats.bytesReceived += frameData.length;
        this.stats.lastFrameTime = Date.now();
        
        // Calculate average FPS (over last 5 seconds to smooth out variations)
        const elapsed = (Date.now() - this.stats.startTime) / 1000;
        if (elapsed > 0) {
            this.stats.averageFps = this.stats.framesReceived / elapsed;
        }

        // Convert BGR24 to ImageData for canvas
        if (this.canvas && this.ctx) {
            try {
                this.renderToCanvas(frameData);
            } catch (error) {
                console.error('Failed to render frame to canvas:', error);
                if (this.errorCallback) {
                    this.errorCallback(`Frame rendering failed: ${error.message}`);
                }
            }
        }

        // Call user-defined frame callback
        if (this.frameCallback) {
            try {
                this.frameCallback(frameData, this.width, this.height, this.stats);
            } catch (error) {
                console.error('Frame callback error:', error);
            }
        }
    }

    /**
     * Render frame to canvas with error handling
     */
    renderToCanvas(bgrData) {
        if (!this.ctx || !this.canvas) {
            throw new Error('Canvas not initialized');
        }

        const imageData = this.ctx.createImageData(this.width, this.height);
        const data = imageData.data;

        // Convert BGR24 to RGBA
        for (let i = 0; i < bgrData.length; i += 3) {
            const pixelIndex = (i / 3) * 4;
            data[pixelIndex] = bgrData[i + 2];     // R (from B)
            data[pixelIndex + 1] = bgrData[i + 1]; // G
            data[pixelIndex + 2] = bgrData[i];     // B (from R)
            data[pixelIndex + 3] = 255;            // A (fully opaque)
        }

        this.ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Disconnect from WebSocket cleanly
     */
    disconnect() {
        console.log('Disconnecting WebSocket client');
        this.isReconnecting = false; // Stop any reconnection attempts
        
        this.stopHeartbeat();
        
        if (this.ws) {
            if (this.ws.readyState === WebSocket.OPEN) {
                this.ws.close(1000, 'Client disconnecting'); // Normal closure
            }
            this.ws = null;
        }
        
        this.isConnected = false;
    }

    /**
     * Set callback for frame reception
     */
    onFrame(callback) {
        this.frameCallback = callback;
    }

    /**
     * Set callback for errors
     */
    onError(callback) {
        this.errorCallback = callback;
    }

    /**
     * Set callback for connection events
     */
    onConnect(callback) {
        this.connectCallback = callback;
    }

    /**
     * Set callback for disconnection events
     */
    onDisconnect(callback) {
        this.disconnectCallback = callback;
    }

    /**
     * Get client statistics
     */
    getStats() {
        return { 
            ...this.stats,
            isConnected: this.isConnected,
            isReconnecting: this.isReconnecting,
            reconnectAttempts: this.reconnectAttempts,
            streamId: this.streamId
        };
    }

    /**
     * Reset statistics
     */
    resetStats() {
        this.stats = {
            framesReceived: 0,
            bytesReceived: 0,
            lastFrameTime: null,
            averageFps: 0,
            startTime: Date.now(),
            reconnectCount: 0
        };
    }

    /**
     * Get connection status
     */
    getConnectionStatus() {
        return {
            isConnected: this.isConnected,
            isReconnecting: this.isReconnecting,
            reconnectAttempts: this.reconnectAttempts,
            maxReconnectAttempts: this.maxReconnectAttempts,
            streamId: this.streamId,
            wsState: this.ws ? this.ws.readyState : null
        };
    }
}

// React Hook for easier integration with improved error handling
if (typeof React !== 'undefined') {
    const { useState, useEffect, useRef, useCallback } = React;

    function useRTSPStream(serverUrl, streamId) {
        const [client] = useState(() => new RTSPStreamClient(serverUrl, streamId));
        const [isConnected, setIsConnected] = useState(false);
        const [isReconnecting, setIsReconnecting] = useState(false);
        const [error, setError] = useState(null);
        const [stats, setStats] = useState(null);
        const [serverStats, setServerStats] = useState(null);
        const canvasRef = useRef(null);

        useEffect(() => {
            if (canvasRef.current) {
                client.setupCanvas(canvasRef.current);
            }

            client.onConnect((event) => {
                console.log('React Hook: Connected');
                setIsConnected(true);
                setIsReconnecting(false);
                setError(null);
            });

            client.onDisconnect((event) => {
                console.log('React Hook: Disconnected');
                setIsConnected(false);
                setIsReconnecting(client.reconnectAttempts > 0 && client.reconnectAttempts < client.maxReconnectAttempts);
            });

            client.onError((errorMsg) => {
                console.error('React Hook: Error:', errorMsg);
                setError(errorMsg);
                setIsReconnecting(false);
            });

            client.onFrame((frameData, width, height, clientStats) => {
                setStats(clientStats);
            });

            // Periodically fetch server stats
            const statsInterval = setInterval(async () => {
                if (client.isConnected) {
                    const serverStats = await client.getStreamStats();
                    setServerStats(serverStats);
                }
            }, 5000); // Every 5 seconds

            return () => {
                clearInterval(statsInterval);
                client.disconnect();
            };
        }, [client]);

        const startStream = useCallback(async (rtspUrl, width = 640, height = 480) => {
            console.log('React Hook: Starting stream...');
            setError(null);
            
            const result = await client.startStreamWithURL(rtspUrl, width, height);
            if (result.success) {
                console.log('React Hook: Stream started, connecting WebSocket...');
                // Wait a moment for stream to initialize
                setTimeout(() => {
                    client.connect();
                }, 1000);
                return result;
            } else {
                setError(result.error);
                return result;
            }
        }, [client]);

        const stopStream = useCallback(async (force = false) => {
            console.log('React Hook: Stopping stream, force:', force);
            client.disconnect();
            
            const result = force ? 
                await client.forceStopStream() : 
                await client.stopStream();
            
            if (!result.success) {
                setError(result.error);
            }
            
            return result;
        }, [client]);

        const reconnect = useCallback(() => {
            console.log('React Hook: Manual reconnect');
            client.disconnect();
            setTimeout(() => {
                client.connect();
            }, 1000);
        }, [client]);

        const getConnectionStatus = useCallback(() => {
            return client.getConnectionStatus();
        }, [client]);

        const listStreams = useCallback(async () => {
            return await client.listStreams();
        }, [client]);

        return {
            canvasRef,
            isConnected,
            isReconnecting,
            error,
            stats, // Client-side stats
            serverStats, // Server-side stats
            startStream,
            stopStream,
            reconnect,
            getConnectionStatus,
            listStreams,
            client
        };
    }

    // Make the hook available globally
    if (typeof window !== 'undefined') {
        window.useRTSPStream = useRTSPStream;
    }
}

// Example usage functions for demonstration
const RTSPStreamExamples = {
    /**
     * Basic usage example
     */
    basicExample: async function() {
        const client = new RTSPStreamClient('ws://localhost:8091');
        
        // Set up event handlers
        client.onConnect(() => console.log('Connected!'));
        client.onError((error) => console.error('Error:', error));
        client.onFrame((data, width, height, stats) => {
            console.log(`Received frame ${stats.framesReceived}, FPS: ${stats.averageFps.toFixed(1)}`);
        });
        
        // Start a stream
        const result = await client.startStreamWithURL('rtsp://your-camera-ip/stream');
        if (result.success) {
            client.connect();
        }
        
        return client;
    },

    /**
     * Canvas rendering example
     */
    canvasExample: async function(canvasElement) {
        const client = new RTSPStreamClient('ws://localhost:8091');
        client.setupCanvas(canvasElement);
        
        const result = await client.startStreamWithURL('rtsp://your-camera-ip/stream', 1920, 1080);
        if (result.success) {
            client.connect();
        }
        
        return client;
    },

    /**
     * Multiple streams example
     */
    multiStreamExample: async function() {
        const streams = [
            'rtsp://camera1/stream',
            'rtsp://camera2/stream',
            'rtsp://camera3/stream'
        ];
        
        const clients = [];
        
        for (let i = 0; i < streams.length; i++) {
            const client = new RTSPStreamClient('ws://localhost:8091', `camera_${i + 1}`);
            
            const result = await client.startStreamWithURL(streams[i]);
            if (result.success) {
                client.connect();
                clients.push(client);
            }
        }
        
        return clients;
    },

    /**
     * Error handling example
     */
    errorHandlingExample: async function() {
        const client = new RTSPStreamClient('ws://localhost:8091');
        
        client.onError((error) => {
            console.error('Stream error:', error);
            // Handle different types of errors
            if (error.includes('WebSocket')) {
                console.log('Connection issue, will retry...');
            } else if (error.includes('Canvas')) {
                console.log('Display issue, check canvas element');
            }
        });
        
        client.onDisconnect((event) => {
            console.log('Disconnected, code:', event.code);
            if (event.code === 1006) {
                console.log('Abnormal disconnection, may need to restart stream');
            }
        });
        
        const result = await client.startStreamWithURL('rtsp://invalid-url');
        if (!result.success) {
            console.log('Failed to start stream:', result.error);
            return null;
        }
        
        client.connect();
        return client;
    },

    /**
     * Stream management example
     */
    streamManagementExample: async function() {
        const client = new RTSPStreamClient('ws://localhost:8091');
        
        // List existing streams
        const streams = await client.listStreams();
        console.log('Existing streams:', streams);
        
        // Start new stream
        const result = await client.startStreamWithURL('rtsp://camera/stream');
        if (!result.success) {
            console.error('Failed to start:', result.error);
            return;
        }
        
        // Connect and get stats
        client.connect();
        
        // Get stats periodically
        const statsInterval = setInterval(async () => {
            const serverStats = await client.getStreamStats();
            const clientStats = client.getStats();
            
            console.log('Server stats:', serverStats);
            console.log('Client stats:', clientStats);
        }, 5000);
        
        // Clean shutdown
        setTimeout(async () => {
            clearInterval(statsInterval);
            
            const stopResult = await client.stopStream();
            if (!stopResult.success && stopResult.conflict) {
                console.log('Other clients connected, force stopping...');
                await client.forceStopStream();
            }
            
            client.disconnect();
        }, 30000); // Stop after 30 seconds
        
        return client;
    }
};

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { RTSPStreamClient, RTSPStreamExamples };
}

// Make available globally
if (typeof window !== 'undefined') {
    window.RTSPStreamClient = RTSPStreamClient;
    window.RTSPStreamExamples = RTSPStreamExamples;
}
